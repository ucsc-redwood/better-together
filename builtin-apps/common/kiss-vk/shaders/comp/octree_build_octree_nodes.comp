// build_octree_nodes.comp
#version 460
layout(local_size_x = 256) in;

layout(std430, set = 0, binding = 0) readonly buffer Codes { uint codes[]; };
layout(std430, set = 0, binding = 1) readonly buffer LeftChild { int left_child[]; };
layout(std430, set = 0, binding = 2) readonly buffer PrefixLength { int prefix_length[]; };
layout(std430, set = 0, binding = 3) readonly buffer EdgeCount { uint edge_count[]; };
layout(std430, set = 0, binding = 4) readonly buffer Offsets { uint offsets[]; };
layout(std430, set = 0, binding = 5) writeonly buffer Children { uint children[]; };

layout(push_constant) uniform PC7 { uint n; }
pc7;

const int MORTON_BITS = 30;

void main() {
  uint ui = gl_GlobalInvocationID.x;
  if (ui >= pc7.n) return;
  int i = int(ui);

  // range + shift
  int j = left_child[i];
  int first = min(i, j), last = max(i, j);
  int depth = prefix_length[i];
  int shift = MORTON_BITS - depth - 3;

  // collect first‚Äêindices per octant
  uint mask = 0u;
  int first_idx[8];
  for (int k = first; k <= last; ++k) {
    uint oct = (codes[k] >> shift) & 0x7u;
    if ((mask & (1u << oct)) == 0u) {
      mask |= (1u << oct);
      first_idx[oct] = k;
    }
  }

  // pack contiguously by counting lower bits
  uint base = offsets[i];
  for (uint oct = 0u; oct < 8u; ++oct) {
    if ((mask & (1u << oct)) != 0u) {
      uint slot = bitCount(mask & ((1u << oct) - 1u));
      children[base + slot] = uint(first_idx[oct]);
    }
  }
}
