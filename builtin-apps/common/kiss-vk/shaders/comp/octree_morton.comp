#version 460

layout(local_size_x = 256) in;

layout(std430, set = 0, binding = 0) readonly buffer Positions { vec4 positions[]; };
layout(std430, set = 0, binding = 1) writeonly buffer MortonKeys { uint morton_keys[]; };

layout(push_constant) uniform PC {
  uint n;
  vec3 bounds_min;
  vec3 bounds_max;
}
pc;

// expand a 10‑bit value so bits are spaced out by two zeros
uint expandBits(uint v) {
  v = (v * 0x00010001u) & 0xFF0000FFu;
  v = (v * 0x00000101u) & 0x0F00F00Fu;
  v = (v * 0x00000011u) & 0xC30C30C3u;
  v = (v * 0x00000005u) & 0x49249249u;
  return v;
}

// pack three 10‑bit coords into a 30‑bit Morton code
uint morton3D_32_encode(uint x, uint y, uint z) {
  return (expandBits(x) << 2) | (expandBits(y) << 1) | expandBits(z);
}

void main() {
  uint i = gl_GlobalInvocationID.x;
  if (i >= pc.n) return;

  vec3 p = positions[i].xyz;
  vec3 d = pc.bounds_max - pc.bounds_min;
  vec3 nrm = (d == vec3(0.0) ? vec3(0.0) : (p - pc.bounds_min) / d);
  nrm = clamp(nrm, 0.0, 1.0);

  uint xi = uint(nrm.x * 1023.0);
  uint yi = uint(nrm.y * 1023.0);
  uint zi = uint(nrm.z * 1023.0);
  morton_keys[i] = morton3D_32_encode(xi, yi, zi);
}
